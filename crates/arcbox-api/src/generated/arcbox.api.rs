// This file is @generated by prost-build.
/// Empty message.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
/// Key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValue {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Mount specification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mount {
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub readonly: bool,
}
/// Port binding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PortBinding {
    #[prost(uint32, tag = "1")]
    pub container_port: u32,
    #[prost(uint32, tag = "2")]
    pub host_port: u32,
    #[prost(string, tag = "3")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub host_ip: ::prost::alloc::string::String,
}
/// Resource limits.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    #[prost(uint64, tag = "1")]
    pub memory_bytes: u64,
    #[prost(uint64, tag = "2")]
    pub cpu_shares: u64,
    #[prost(int64, tag = "3")]
    pub cpu_quota: i64,
    #[prost(uint64, tag = "4")]
    pub cpu_period: u64,
    #[prost(double, tag = "5")]
    pub cpus: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContainerRequest {
    /// Container name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Image reference.
    #[prost(string, tag = "2")]
    pub image: ::prost::alloc::string::String,
    /// Command to run.
    #[prost(string, repeated, tag = "3")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Entrypoint.
    #[prost(string, repeated, tag = "4")]
    pub entrypoint: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables.
    #[prost(map = "string, string", tag = "5")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Working directory.
    #[prost(string, tag = "6")]
    pub working_dir: ::prost::alloc::string::String,
    /// User.
    #[prost(string, tag = "7")]
    pub user: ::prost::alloc::string::String,
    /// Mounts.
    #[prost(message, repeated, tag = "8")]
    pub mounts: ::prost::alloc::vec::Vec<Mount>,
    /// Port bindings.
    #[prost(message, repeated, tag = "9")]
    pub ports: ::prost::alloc::vec::Vec<PortBinding>,
    /// Labels.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// TTY allocation.
    #[prost(bool, tag = "11")]
    pub tty: bool,
    /// Keep stdin open.
    #[prost(bool, tag = "12")]
    pub stdin_open: bool,
    /// Resource limits.
    #[prost(message, optional, tag = "13")]
    pub resources: ::core::option::Option<ResourceLimits>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContainerResponse {
    /// Container ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Warnings.
    #[prost(string, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartContainerResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Timeout in seconds before killing.
    #[prost(uint32, tag = "2")]
    pub timeout: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopContainerResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Force removal.
    #[prost(bool, tag = "2")]
    pub force: bool,
    /// Remove volumes.
    #[prost(bool, tag = "3")]
    pub remove_volumes: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveContainerResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContainersRequest {
    /// Show all containers (including stopped).
    #[prost(bool, tag = "1")]
    pub all: bool,
    /// Limit number of results.
    #[prost(int32, tag = "2")]
    pub limit: i32,
    /// Filter by labels.
    #[prost(map = "string, string", tag = "3")]
    pub filters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContainersResponse {
    #[prost(message, repeated, tag = "1")]
    pub containers: ::prost::alloc::vec::Vec<ContainerSummary>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerSummary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub state: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub created: i64,
    #[prost(message, repeated, tag = "7")]
    pub ports: ::prost::alloc::vec::Vec<PortBinding>,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectContainerResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created: i64,
    #[prost(message, optional, tag = "5")]
    pub state: ::core::option::Option<ContainerState>,
    #[prost(string, repeated, tag = "6")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub entrypoint: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "8")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "9")]
    pub working_dir: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub mounts: ::prost::alloc::vec::Vec<Mount>,
    #[prost(message, repeated, tag = "11")]
    pub ports: ::prost::alloc::vec::Vec<PortBinding>,
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerState {
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub running: bool,
    #[prost(bool, tag = "3")]
    pub paused: bool,
    #[prost(bool, tag = "4")]
    pub restarting: bool,
    #[prost(bool, tag = "5")]
    pub dead: bool,
    #[prost(int32, tag = "6")]
    pub pid: i32,
    #[prost(int32, tag = "7")]
    pub exit_code: i32,
    #[prost(string, tag = "8")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub started_at: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub finished_at: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Condition to wait for: "not-running", "next-exit", "removed".
    #[prost(string, tag = "2")]
    pub condition: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitContainerResponse {
    /// Exit code.
    #[prost(int64, tag = "1")]
    pub status_code: i64,
    /// Error message if any.
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContainerLogsRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Follow log output.
    #[prost(bool, tag = "2")]
    pub follow: bool,
    /// Show stdout.
    #[prost(bool, tag = "3")]
    pub stdout: bool,
    /// Show stderr.
    #[prost(bool, tag = "4")]
    pub stderr: bool,
    /// Show timestamps.
    #[prost(bool, tag = "5")]
    pub timestamps: bool,
    /// Only entries since this timestamp (Unix seconds).
    #[prost(int64, tag = "6")]
    pub since: i64,
    /// Only entries until this timestamp (Unix seconds).
    #[prost(int64, tag = "7")]
    pub until: i64,
    /// Tail N lines (0 = all).
    #[prost(int64, tag = "8")]
    pub tail: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogEntry {
    /// Stream type: "stdout" or "stderr".
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Log data.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp (Unix nanoseconds).
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecContainerRequest {
    /// Container ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Command to execute.
    #[prost(string, repeated, tag = "2")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables.
    #[prost(map = "string, string", tag = "3")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Working directory.
    #[prost(string, tag = "4")]
    pub working_dir: ::prost::alloc::string::String,
    /// User.
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    /// Allocate TTY.
    #[prost(bool, tag = "6")]
    pub tty: bool,
    /// Attach stdin.
    #[prost(bool, tag = "7")]
    pub stdin: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecOutput {
    /// Stream type: "stdout" or "stderr".
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Output data.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Exit code (only set when done).
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    /// Is this the final message.
    #[prost(bool, tag = "4")]
    pub done: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMachineRequest {
    /// Machine name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Number of CPUs.
    #[prost(uint32, tag = "2")]
    pub cpus: u32,
    /// Memory in bytes.
    #[prost(uint64, tag = "3")]
    pub memory: u64,
    /// Disk size in bytes.
    #[prost(uint64, tag = "4")]
    pub disk_size: u64,
    /// Kernel path (optional).
    #[prost(string, tag = "5")]
    pub kernel: ::prost::alloc::string::String,
    /// Initrd path (optional).
    #[prost(string, tag = "6")]
    pub initrd: ::prost::alloc::string::String,
    /// Kernel command line.
    #[prost(string, tag = "7")]
    pub cmdline: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMachineResponse {
    /// Machine ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartMachineRequest {
    /// Machine ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartMachineResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopMachineRequest {
    /// Machine ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Force stop.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopMachineResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveMachineRequest {
    /// Machine ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Force removal.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RemoveMachineResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListMachinesRequest {
    /// Show all machines.
    #[prost(bool, tag = "1")]
    pub all: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachinesResponse {
    #[prost(message, repeated, tag = "1")]
    pub machines: ::prost::alloc::vec::Vec<MachineSummary>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineSummary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub cpus: u32,
    #[prost(uint64, tag = "5")]
    pub memory: u64,
    #[prost(int64, tag = "6")]
    pub created: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectMachineRequest {
    /// Machine ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectMachineResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub cpus: u32,
    #[prost(uint64, tag = "5")]
    pub memory: u64,
    #[prost(uint64, tag = "6")]
    pub disk_size: u64,
    #[prost(int64, tag = "7")]
    pub created: i64,
    #[prost(string, tag = "8")]
    pub kernel: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub initrd: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub cmdline: ::prost::alloc::string::String,
    /// CID for vsock communication.
    #[prost(uint32, tag = "11")]
    pub cid: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecMachineRequest {
    /// Machine ID or name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Command to execute.
    #[prost(string, repeated, tag = "2")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables.
    #[prost(map = "string, string", tag = "3")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Working directory.
    #[prost(string, tag = "4")]
    pub working_dir: ::prost::alloc::string::String,
    /// User.
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    /// Allocate TTY.
    #[prost(bool, tag = "6")]
    pub tty: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellInput {
    /// Input data.
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Resize terminal.
    #[prost(message, optional, tag = "2")]
    pub resize: ::core::option::Option<TerminalSize>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellOutput {
    /// Output data.
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Exit code (only set when done).
    #[prost(int32, tag = "2")]
    pub exit_code: i32,
    /// Is this the final message.
    #[prost(bool, tag = "3")]
    pub done: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminalSize {
    #[prost(uint32, tag = "1")]
    pub width: u32,
    #[prost(uint32, tag = "2")]
    pub height: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullImageRequest {
    /// Image reference (e.g., "alpine:latest").
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// Platform (e.g., "linux/arm64").
    #[prost(string, tag = "2")]
    pub platform: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullProgress {
    /// Status message.
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    /// Layer ID.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// Progress detail.
    #[prost(string, tag = "3")]
    pub progress: ::prost::alloc::string::String,
    /// Error message if any.
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveImageRequest {
    /// Image reference or ID.
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// Force removal.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveImageResponse {
    /// Untagged images.
    #[prost(string, repeated, tag = "1")]
    pub untagged: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Deleted images.
    #[prost(string, repeated, tag = "2")]
    pub deleted: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesRequest {
    /// Show all images.
    #[prost(bool, tag = "1")]
    pub all: bool,
    /// Filter by labels.
    #[prost(map = "string, string", tag = "2")]
    pub filters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesResponse {
    #[prost(message, repeated, tag = "1")]
    pub images: ::prost::alloc::vec::Vec<ImageSummary>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageSummary {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub repo_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub repo_digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub created: i64,
    #[prost(int64, tag = "5")]
    pub size: i64,
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectImageRequest {
    /// Image reference or ID.
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectImageResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub repo_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub repo_digests: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub comment: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub created: i64,
    #[prost(string, tag = "7")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub architecture: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub os: ::prost::alloc::string::String,
    #[prost(int64, tag = "10")]
    pub size: i64,
    #[prost(string, repeated, tag = "11")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "12")]
    pub entrypoint: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "13")]
    pub env: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "14")]
    pub working_dir: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "15")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TagImageRequest {
    /// Source image reference or ID.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// Target repository.
    #[prost(string, tag = "2")]
    pub repo: ::prost::alloc::string::String,
    /// Target tag.
    #[prost(string, tag = "3")]
    pub tag: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TagImageResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    /// Number of containers.
    #[prost(int64, tag = "1")]
    pub containers: i64,
    /// Running containers.
    #[prost(int64, tag = "2")]
    pub containers_running: i64,
    /// Paused containers.
    #[prost(int64, tag = "3")]
    pub containers_paused: i64,
    /// Stopped containers.
    #[prost(int64, tag = "4")]
    pub containers_stopped: i64,
    /// Number of images.
    #[prost(int64, tag = "5")]
    pub images: i64,
    /// Number of machines.
    #[prost(int64, tag = "6")]
    pub machines: i64,
    /// Running machines.
    #[prost(int64, tag = "7")]
    pub machines_running: i64,
    /// Server version.
    #[prost(string, tag = "8")]
    pub server_version: ::prost::alloc::string::String,
    /// Operating system.
    #[prost(string, tag = "9")]
    pub os: ::prost::alloc::string::String,
    /// Architecture.
    #[prost(string, tag = "10")]
    pub arch: ::prost::alloc::string::String,
    /// Total memory.
    #[prost(int64, tag = "11")]
    pub mem_total: i64,
    /// Number of CPUs.
    #[prost(int32, tag = "12")]
    pub ncpu: i32,
    /// Data directory.
    #[prost(string, tag = "13")]
    pub data_dir: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    /// Version string.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// API version.
    #[prost(string, tag = "2")]
    pub api_version: ::prost::alloc::string::String,
    /// Git commit.
    #[prost(string, tag = "3")]
    pub git_commit: ::prost::alloc::string::String,
    /// Build time.
    #[prost(string, tag = "4")]
    pub build_time: ::prost::alloc::string::String,
    /// OS.
    #[prost(string, tag = "5")]
    pub os: ::prost::alloc::string::String,
    /// Architecture.
    #[prost(string, tag = "6")]
    pub arch: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingResponse {
    /// API version.
    #[prost(string, tag = "1")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod container_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ContainerService manages container lifecycle.
    #[derive(Debug, Clone)]
    pub struct ContainerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContainerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContainerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContainerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContainerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new container.
        pub async fn create_container(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/CreateContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("arcbox.api.ContainerService", "CreateContainer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts a container.
        pub async fn start_container(
            &mut self,
            request: impl tonic::IntoRequest<super::StartContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/StartContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("arcbox.api.ContainerService", "StartContainer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops a container.
        pub async fn stop_container(
            &mut self,
            request: impl tonic::IntoRequest<super::StopContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/StopContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ContainerService", "StopContainer"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes a container.
        pub async fn remove_container(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/RemoveContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("arcbox.api.ContainerService", "RemoveContainer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists containers.
        pub async fn list_containers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContainersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContainersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/ListContainers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("arcbox.api.ContainerService", "ListContainers"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inspects a container.
        pub async fn inspect_container(
            &mut self,
            request: impl tonic::IntoRequest<super::InspectContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/InspectContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("arcbox.api.ContainerService", "InspectContainer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Waits for a container to exit.
        pub async fn wait_container(
            &mut self,
            request: impl tonic::IntoRequest<super::WaitContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WaitContainerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/WaitContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ContainerService", "WaitContainer"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets container logs.
        pub async fn container_logs(
            &mut self,
            request: impl tonic::IntoRequest<super::ContainerLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::LogEntry>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/ContainerLogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ContainerService", "ContainerLogs"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Executes a command in a container.
        pub async fn exec_container(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExecOutput>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ContainerService/ExecContainer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ContainerService", "ExecContainer"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod machine_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// MachineService manages virtual machine lifecycle.
    #[derive(Debug, Clone)]
    pub struct MachineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MachineServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MachineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MachineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new VM.
        pub async fn create_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateMachineResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/CreateMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "CreateMachine"));
            self.inner.unary(req, path, codec).await
        }
        /// Starts a VM.
        pub async fn start_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::StartMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartMachineResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/StartMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "StartMachine"));
            self.inner.unary(req, path, codec).await
        }
        /// Stops a VM.
        pub async fn stop_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::StopMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopMachineResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/StopMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "StopMachine"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes a VM.
        pub async fn remove_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveMachineResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/RemoveMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "RemoveMachine"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists VMs.
        pub async fn list_machines(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMachinesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMachinesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/ListMachines",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "ListMachines"));
            self.inner.unary(req, path, codec).await
        }
        /// Inspects a VM.
        pub async fn inspect_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::InspectMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectMachineResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/InspectMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "InspectMachine"));
            self.inner.unary(req, path, codec).await
        }
        /// Executes a command in a VM.
        pub async fn exec_machine(
            &mut self,
            request: impl tonic::IntoRequest<super::ExecMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExecOutput>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/ExecMachine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "ExecMachine"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Opens an interactive shell to a VM.
        pub async fn shell_machine(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ShellInput>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ShellOutput>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.MachineService/ShellMachine",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.MachineService", "ShellMachine"));
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod image_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ImageService manages container images.
    #[derive(Debug, Clone)]
    pub struct ImageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ImageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ImageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ImageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ImageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Pulls an image from a registry.
        pub async fn pull_image(
            &mut self,
            request: impl tonic::IntoRequest<super::PullImageRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PullProgress>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ImageService/PullImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ImageService", "PullImage"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Removes an image.
        pub async fn remove_image(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveImageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ImageService/RemoveImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ImageService", "RemoveImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists images.
        pub async fn list_images(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListImagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ImageService/ListImages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ImageService", "ListImages"));
            self.inner.unary(req, path, codec).await
        }
        /// Inspects an image.
        pub async fn inspect_image(
            &mut self,
            request: impl tonic::IntoRequest<super::InspectImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectImageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ImageService/InspectImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ImageService", "InspectImage"));
            self.inner.unary(req, path, codec).await
        }
        /// Tags an image.
        pub async fn tag_image(
            &mut self,
            request: impl tonic::IntoRequest<super::TagImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TagImageResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.ImageService/TagImage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.ImageService", "TagImage"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod system_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// SystemService provides system-level operations.
    #[derive(Debug, Clone)]
    pub struct SystemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SystemServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SystemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SystemServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SystemServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets system information.
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.SystemService/GetInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.SystemService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets version information.
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.SystemService/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.SystemService", "GetVersion"));
            self.inner.unary(req, path, codec).await
        }
        /// Pings the server.
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<super::PingRequest>,
        ) -> std::result::Result<tonic::Response<super::PingResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/arcbox.api.SystemService/Ping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("arcbox.api.SystemService", "Ping"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod container_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ContainerServiceServer.
    #[async_trait]
    pub trait ContainerService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a new container.
        async fn create_container(
            &self,
            request: tonic::Request<super::CreateContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateContainerResponse>,
            tonic::Status,
        >;
        /// Starts a container.
        async fn start_container(
            &self,
            request: tonic::Request<super::StartContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartContainerResponse>,
            tonic::Status,
        >;
        /// Stops a container.
        async fn stop_container(
            &self,
            request: tonic::Request<super::StopContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopContainerResponse>,
            tonic::Status,
        >;
        /// Removes a container.
        async fn remove_container(
            &self,
            request: tonic::Request<super::RemoveContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveContainerResponse>,
            tonic::Status,
        >;
        /// Lists containers.
        async fn list_containers(
            &self,
            request: tonic::Request<super::ListContainersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContainersResponse>,
            tonic::Status,
        >;
        /// Inspects a container.
        async fn inspect_container(
            &self,
            request: tonic::Request<super::InspectContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectContainerResponse>,
            tonic::Status,
        >;
        /// Waits for a container to exit.
        async fn wait_container(
            &self,
            request: tonic::Request<super::WaitContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::WaitContainerResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the ContainerLogs method.
        type ContainerLogsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::LogEntry, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Gets container logs.
        async fn container_logs(
            &self,
            request: tonic::Request<super::ContainerLogsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ContainerLogsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ExecContainer method.
        type ExecContainerStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ExecOutput, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Executes a command in a container.
        async fn exec_container(
            &self,
            request: tonic::Request<super::ExecContainerRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ExecContainerStream>,
            tonic::Status,
        >;
    }
    /// ContainerService manages container lifecycle.
    #[derive(Debug)]
    pub struct ContainerServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ContainerServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ContainerServiceServer<T>
    where
        T: ContainerService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/arcbox.api.ContainerService/CreateContainer" => {
                    #[allow(non_camel_case_types)]
                    struct CreateContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::CreateContainerRequest>
                    for CreateContainerSvc<T> {
                        type Response = super::CreateContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::create_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/StartContainer" => {
                    #[allow(non_camel_case_types)]
                    struct StartContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::StartContainerRequest>
                    for StartContainerSvc<T> {
                        type Response = super::StartContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::start_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/StopContainer" => {
                    #[allow(non_camel_case_types)]
                    struct StopContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::StopContainerRequest>
                    for StopContainerSvc<T> {
                        type Response = super::StopContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::stop_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/RemoveContainer" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::RemoveContainerRequest>
                    for RemoveContainerSvc<T> {
                        type Response = super::RemoveContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::remove_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/ListContainers" => {
                    #[allow(non_camel_case_types)]
                    struct ListContainersSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::ListContainersRequest>
                    for ListContainersSvc<T> {
                        type Response = super::ListContainersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListContainersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::list_containers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListContainersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/InspectContainer" => {
                    #[allow(non_camel_case_types)]
                    struct InspectContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::InspectContainerRequest>
                    for InspectContainerSvc<T> {
                        type Response = super::InspectContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InspectContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::inspect_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InspectContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/WaitContainer" => {
                    #[allow(non_camel_case_types)]
                    struct WaitContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::UnaryService<super::WaitContainerRequest>
                    for WaitContainerSvc<T> {
                        type Response = super::WaitContainerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WaitContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::wait_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WaitContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/ContainerLogs" => {
                    #[allow(non_camel_case_types)]
                    struct ContainerLogsSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::ServerStreamingService<super::ContainerLogsRequest>
                    for ContainerLogsSvc<T> {
                        type Response = super::LogEntry;
                        type ResponseStream = T::ContainerLogsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ContainerLogsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::container_logs(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ContainerLogsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ContainerService/ExecContainer" => {
                    #[allow(non_camel_case_types)]
                    struct ExecContainerSvc<T: ContainerService>(pub Arc<T>);
                    impl<
                        T: ContainerService,
                    > tonic::server::ServerStreamingService<super::ExecContainerRequest>
                    for ExecContainerSvc<T> {
                        type Response = super::ExecOutput;
                        type ResponseStream = T::ExecContainerStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecContainerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ContainerService>::exec_container(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecContainerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ContainerServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "arcbox.api.ContainerService";
    impl<T> tonic::server::NamedService for ContainerServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod machine_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with MachineServiceServer.
    #[async_trait]
    pub trait MachineService: std::marker::Send + std::marker::Sync + 'static {
        /// Creates a new VM.
        async fn create_machine(
            &self,
            request: tonic::Request<super::CreateMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateMachineResponse>,
            tonic::Status,
        >;
        /// Starts a VM.
        async fn start_machine(
            &self,
            request: tonic::Request<super::StartMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartMachineResponse>,
            tonic::Status,
        >;
        /// Stops a VM.
        async fn stop_machine(
            &self,
            request: tonic::Request<super::StopMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StopMachineResponse>,
            tonic::Status,
        >;
        /// Removes a VM.
        async fn remove_machine(
            &self,
            request: tonic::Request<super::RemoveMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveMachineResponse>,
            tonic::Status,
        >;
        /// Lists VMs.
        async fn list_machines(
            &self,
            request: tonic::Request<super::ListMachinesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMachinesResponse>,
            tonic::Status,
        >;
        /// Inspects a VM.
        async fn inspect_machine(
            &self,
            request: tonic::Request<super::InspectMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectMachineResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the ExecMachine method.
        type ExecMachineStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ExecOutput, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Executes a command in a VM.
        async fn exec_machine(
            &self,
            request: tonic::Request<super::ExecMachineRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::ExecMachineStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ShellMachine method.
        type ShellMachineStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ShellOutput, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Opens an interactive shell to a VM.
        async fn shell_machine(
            &self,
            request: tonic::Request<tonic::Streaming<super::ShellInput>>,
        ) -> std::result::Result<
            tonic::Response<Self::ShellMachineStream>,
            tonic::Status,
        >;
    }
    /// MachineService manages virtual machine lifecycle.
    #[derive(Debug)]
    pub struct MachineServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> MachineServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for MachineServiceServer<T>
    where
        T: MachineService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/arcbox.api.MachineService/CreateMachine" => {
                    #[allow(non_camel_case_types)]
                    struct CreateMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::CreateMachineRequest>
                    for CreateMachineSvc<T> {
                        type Response = super::CreateMachineResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::create_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/StartMachine" => {
                    #[allow(non_camel_case_types)]
                    struct StartMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::StartMachineRequest>
                    for StartMachineSvc<T> {
                        type Response = super::StartMachineResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StartMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::start_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StartMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/StopMachine" => {
                    #[allow(non_camel_case_types)]
                    struct StopMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::StopMachineRequest>
                    for StopMachineSvc<T> {
                        type Response = super::StopMachineResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::stop_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/RemoveMachine" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::RemoveMachineRequest>
                    for RemoveMachineSvc<T> {
                        type Response = super::RemoveMachineResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::remove_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/ListMachines" => {
                    #[allow(non_camel_case_types)]
                    struct ListMachinesSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::ListMachinesRequest>
                    for ListMachinesSvc<T> {
                        type Response = super::ListMachinesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListMachinesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::list_machines(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListMachinesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/InspectMachine" => {
                    #[allow(non_camel_case_types)]
                    struct InspectMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::UnaryService<super::InspectMachineRequest>
                    for InspectMachineSvc<T> {
                        type Response = super::InspectMachineResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InspectMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::inspect_machine(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InspectMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/ExecMachine" => {
                    #[allow(non_camel_case_types)]
                    struct ExecMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::ServerStreamingService<super::ExecMachineRequest>
                    for ExecMachineSvc<T> {
                        type Response = super::ExecOutput;
                        type ResponseStream = T::ExecMachineStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecMachineRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::exec_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExecMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.MachineService/ShellMachine" => {
                    #[allow(non_camel_case_types)]
                    struct ShellMachineSvc<T: MachineService>(pub Arc<T>);
                    impl<
                        T: MachineService,
                    > tonic::server::StreamingService<super::ShellInput>
                    for ShellMachineSvc<T> {
                        type Response = super::ShellOutput;
                        type ResponseStream = T::ShellMachineStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<tonic::Streaming<super::ShellInput>>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as MachineService>::shell_machine(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ShellMachineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for MachineServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "arcbox.api.MachineService";
    impl<T> tonic::server::NamedService for MachineServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod image_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ImageServiceServer.
    #[async_trait]
    pub trait ImageService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the PullImage method.
        type PullImageStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PullProgress, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Pulls an image from a registry.
        async fn pull_image(
            &self,
            request: tonic::Request<super::PullImageRequest>,
        ) -> std::result::Result<tonic::Response<Self::PullImageStream>, tonic::Status>;
        /// Removes an image.
        async fn remove_image(
            &self,
            request: tonic::Request<super::RemoveImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveImageResponse>,
            tonic::Status,
        >;
        /// Lists images.
        async fn list_images(
            &self,
            request: tonic::Request<super::ListImagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListImagesResponse>,
            tonic::Status,
        >;
        /// Inspects an image.
        async fn inspect_image(
            &self,
            request: tonic::Request<super::InspectImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InspectImageResponse>,
            tonic::Status,
        >;
        /// Tags an image.
        async fn tag_image(
            &self,
            request: tonic::Request<super::TagImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TagImageResponse>,
            tonic::Status,
        >;
    }
    /// ImageService manages container images.
    #[derive(Debug)]
    pub struct ImageServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ImageServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ImageServiceServer<T>
    where
        T: ImageService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/arcbox.api.ImageService/PullImage" => {
                    #[allow(non_camel_case_types)]
                    struct PullImageSvc<T: ImageService>(pub Arc<T>);
                    impl<
                        T: ImageService,
                    > tonic::server::ServerStreamingService<super::PullImageRequest>
                    for PullImageSvc<T> {
                        type Response = super::PullProgress;
                        type ResponseStream = T::PullImageStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PullImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImageService>::pull_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PullImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ImageService/RemoveImage" => {
                    #[allow(non_camel_case_types)]
                    struct RemoveImageSvc<T: ImageService>(pub Arc<T>);
                    impl<
                        T: ImageService,
                    > tonic::server::UnaryService<super::RemoveImageRequest>
                    for RemoveImageSvc<T> {
                        type Response = super::RemoveImageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RemoveImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImageService>::remove_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RemoveImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ImageService/ListImages" => {
                    #[allow(non_camel_case_types)]
                    struct ListImagesSvc<T: ImageService>(pub Arc<T>);
                    impl<
                        T: ImageService,
                    > tonic::server::UnaryService<super::ListImagesRequest>
                    for ListImagesSvc<T> {
                        type Response = super::ListImagesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListImagesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImageService>::list_images(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListImagesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ImageService/InspectImage" => {
                    #[allow(non_camel_case_types)]
                    struct InspectImageSvc<T: ImageService>(pub Arc<T>);
                    impl<
                        T: ImageService,
                    > tonic::server::UnaryService<super::InspectImageRequest>
                    for InspectImageSvc<T> {
                        type Response = super::InspectImageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::InspectImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImageService>::inspect_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InspectImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.ImageService/TagImage" => {
                    #[allow(non_camel_case_types)]
                    struct TagImageSvc<T: ImageService>(pub Arc<T>);
                    impl<
                        T: ImageService,
                    > tonic::server::UnaryService<super::TagImageRequest>
                    for TagImageSvc<T> {
                        type Response = super::TagImageResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TagImageRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ImageService>::tag_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = TagImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ImageServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "arcbox.api.ImageService";
    impl<T> tonic::server::NamedService for ImageServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod system_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SystemServiceServer.
    #[async_trait]
    pub trait SystemService: std::marker::Send + std::marker::Sync + 'static {
        /// Gets system information.
        async fn get_info(
            &self,
            request: tonic::Request<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status>;
        /// Gets version information.
        async fn get_version(
            &self,
            request: tonic::Request<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVersionResponse>,
            tonic::Status,
        >;
        /// Pings the server.
        async fn ping(
            &self,
            request: tonic::Request<super::PingRequest>,
        ) -> std::result::Result<tonic::Response<super::PingResponse>, tonic::Status>;
    }
    /// SystemService provides system-level operations.
    #[derive(Debug)]
    pub struct SystemServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SystemServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SystemServiceServer<T>
    where
        T: SystemService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/arcbox.api.SystemService/GetInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetInfoSvc<T: SystemService>(pub Arc<T>);
                    impl<
                        T: SystemService,
                    > tonic::server::UnaryService<super::GetInfoRequest>
                    for GetInfoSvc<T> {
                        type Response = super::GetInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemService>::get_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.SystemService/GetVersion" => {
                    #[allow(non_camel_case_types)]
                    struct GetVersionSvc<T: SystemService>(pub Arc<T>);
                    impl<
                        T: SystemService,
                    > tonic::server::UnaryService<super::GetVersionRequest>
                    for GetVersionSvc<T> {
                        type Response = super::GetVersionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetVersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemService>::get_version(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetVersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/arcbox.api.SystemService/Ping" => {
                    #[allow(non_camel_case_types)]
                    struct PingSvc<T: SystemService>(pub Arc<T>);
                    impl<
                        T: SystemService,
                    > tonic::server::UnaryService<super::PingRequest> for PingSvc<T> {
                        type Response = super::PingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemService>::ping(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = PingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SystemServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "arcbox.api.SystemService";
    impl<T> tonic::server::NamedService for SystemServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
