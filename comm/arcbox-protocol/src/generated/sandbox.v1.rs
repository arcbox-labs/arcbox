// This file is @generated by prost-build.
/// Empty response / request.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
/// Network configuration for a sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkSpec {
    /// Network mode: "tap" (default, TAP + IP pool) or "none" (no network).
    #[prost(string, tag = "1")]
    pub mode: ::prost::alloc::string::String,
    /// Static IP address. Empty = allocate from pool.
    #[prost(string, optional, tag = "2")]
    pub ip: ::core::option::Option<::prost::alloc::string::String>,
    /// Egress bandwidth cap in bytes/s (0 = unlimited).
    #[prost(uint64, tag = "3")]
    pub egress_bps: u64,
    /// Ingress bandwidth cap in bytes/s (0 = unlimited).
    #[prost(uint64, tag = "4")]
    pub ingress_bps: u64,
}
/// A single bind mount into the sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mount {
    /// Source path on the host.
    #[prost(string, tag = "1")]
    pub source: ::prost::alloc::string::String,
    /// Target path inside the sandbox.
    #[prost(string, tag = "2")]
    pub target: ::prost::alloc::string::String,
    /// Mount read-only.
    #[prost(bool, tag = "3")]
    pub readonly: bool,
}
/// CPU and memory resource limits.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceLimits {
    /// Number of vCPUs (0 = daemon default).
    #[prost(uint32, tag = "1")]
    pub vcpus: u32,
    /// Memory in MiB (0 = daemon default).
    #[prost(uint64, tag = "2")]
    pub memory_mib: u64,
}
/// Terminal size for TTY resize events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminalSize {
    /// Terminal width in columns.
    #[prost(uint32, tag = "1")]
    pub width: u32,
    /// Terminal height in rows.
    #[prost(uint32, tag = "2")]
    pub height: u32,
}
/// Request to create a sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxRequest {
    /// Caller-supplied unique ID for idempotent creation.
    /// If empty the daemon generates a UUID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Arbitrary key-value metadata (used for filtering in List / Events).
    #[prost(map = "string, string", tag = "2")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// --- VM image ---
    /// Kernel image path (empty = daemon default).
    #[prost(string, tag = "3")]
    pub kernel: ::prost::alloc::string::String,
    /// Root filesystem image path (empty = daemon default).
    #[prost(string, tag = "4")]
    pub rootfs: ::prost::alloc::string::String,
    /// Kernel command-line arguments (empty = daemon default).
    #[prost(string, tag = "5")]
    pub boot_args: ::prost::alloc::string::String,
    /// --- Resources ---
    #[prost(message, optional, tag = "6")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// --- Initial workload (optional) ---
    /// OCI image reference. When set, the agent pulls and runs this image
    /// inside the sandbox. Empty = use rootfs directly.
    #[prost(string, tag = "7")]
    pub image: ::prost::alloc::string::String,
    /// Initial command launched automatically after boot.
    /// Empty = sandbox enters "ready" without running anything.
    /// When this process exits the sandbox transitions back to "ready"
    /// (NOT destroyed) and continues accepting Run calls.
    #[prost(string, repeated, tag = "8")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variables for the initial command.
    #[prost(map = "string, string", tag = "9")]
    pub env:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Working directory for the initial command.
    #[prost(string, tag = "10")]
    pub working_dir: ::prost::alloc::string::String,
    /// User to run the initial command as.
    #[prost(string, tag = "11")]
    pub user: ::prost::alloc::string::String,
    /// --- Filesystem ---
    #[prost(message, repeated, tag = "12")]
    pub mounts: ::prost::alloc::vec::Vec<Mount>,
    /// --- Network ---
    #[prost(message, optional, tag = "13")]
    pub network: ::core::option::Option<NetworkSpec>,
    /// --- Lifecycle ---
    /// Sandbox auto-destruction timeout in seconds (0 = no limit).
    /// The timer starts from the moment the sandbox is created and is not
    /// reset by workload activity.
    #[prost(uint32, tag = "14")]
    pub ttl_seconds: u32,
    /// --- Provisioning ---
    /// SSH public key injected via MMDS (empty = no SSH).
    #[prost(string, optional, tag = "15")]
    pub ssh_public_key: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response to CreateSandbox.
/// Returned immediately; the sandbox may still be booting (state "starting").
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxResponse {
    /// Assigned or caller-supplied sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// IP address pre-allocated for the sandbox (empty if mode = "none").
    /// Available even while state is "starting".
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
    /// State at time of response: always "starting".
    #[prost(string, tag = "3")]
    pub state: ::prost::alloc::string::String,
}
/// Request to run a command inside a ready sandbox.
/// The sandbox must be in "ready" or "idle" state; if it is "running" the call
/// returns FAILED_PRECONDITION.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunRequest {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Command and arguments.
    #[prost(string, repeated, tag = "2")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variable overrides.
    #[prost(map = "string, string", tag = "3")]
    pub env:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Working directory (empty = rootfs default).
    #[prost(string, tag = "4")]
    pub working_dir: ::prost::alloc::string::String,
    /// User to run as (empty = rootfs default).
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    /// Allocate a pseudo-TTY.
    #[prost(bool, tag = "6")]
    pub tty: bool,
    /// Kill the command after this many seconds (0 = no timeout).
    #[prost(uint32, tag = "7")]
    pub timeout_seconds: u32,
}
/// A single chunk of streaming output from Run.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunOutput {
    /// Stream name: "stdout" | "stderr" | "exit".
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Raw output bytes (empty when stream == "exit").
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Process exit code. Only valid on the final message (done == true).
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    /// True on the last message of the stream.
    #[prost(bool, tag = "4")]
    pub done: bool,
}
/// A single message sent by the client during an Exec session.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecInput {
    #[prost(oneof = "exec_input::Payload", tags = "1, 2, 3")]
    pub payload: ::core::option::Option<exec_input::Payload>,
}
/// Nested message and enum types in `ExecInput`.
pub mod exec_input {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// Must be the first message in the stream. Carries command parameters.
        #[prost(message, tag = "1")]
        Init(super::ExecRequest),
        /// Subsequent messages: raw bytes forwarded to the process stdin.
        #[prost(bytes, tag = "2")]
        Stdin(::prost::alloc::vec::Vec<u8>),
        /// Resize the pseudo-TTY. Only valid when ExecRequest.tty == true.
        #[prost(message, tag = "3")]
        Resize(super::TerminalSize),
    }
}
/// Parameters for starting an exec session. Sent as ExecInput{init: ...}.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecRequest {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Command and arguments.
    #[prost(string, repeated, tag = "2")]
    pub cmd: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Environment variable overrides.
    #[prost(map = "string, string", tag = "3")]
    pub env:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Working directory.
    #[prost(string, tag = "4")]
    pub working_dir: ::prost::alloc::string::String,
    /// User to run as.
    #[prost(string, tag = "5")]
    pub user: ::prost::alloc::string::String,
    /// Allocate a pseudo-TTY.
    #[prost(bool, tag = "6")]
    pub tty: bool,
    /// Initial terminal size (required when tty == true).
    #[prost(message, optional, tag = "7")]
    pub tty_size: ::core::option::Option<TerminalSize>,
    /// Kill the command after this many seconds (0 = no timeout).
    #[prost(uint32, tag = "8")]
    pub timeout_seconds: u32,
}
/// A single chunk of streaming output from Exec.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecOutput {
    /// Stream name: "stdout" | "stderr" | "exit".
    #[prost(string, tag = "1")]
    pub stream: ::prost::alloc::string::String,
    /// Raw output bytes (empty when stream == "exit").
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// Process exit code. Only valid on the final message (done == true).
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    /// True on the last message of the stream.
    #[prost(bool, tag = "4")]
    pub done: bool,
}
/// Request to stop a sandbox gracefully.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopSandboxRequest {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Seconds to wait for any active workload to exit before force-killing
    /// the VM (0 = daemon default of 30 s).
    #[prost(uint32, tag = "2")]
    pub timeout_seconds: u32,
}
/// Request to forcibly remove a sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveSandboxRequest {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Force removal even if the sandbox is in "running" state.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request to inspect a sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InspectSandboxRequest {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Full sandbox state.
///
/// State machine:
///
///    starting ──► ready ──► running ──► ready   (cmd/Run exited, sandbox alive)
///                   │          │
///                   └──────────┴──► stopping ──► stopped
///                                        │
///                                     failed
///
/// "idle" is an alias for "ready" used in event payloads to signal that a
/// previously running workload has just finished.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxInfo {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// State: starting | ready | running | stopping | stopped | failed.
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    /// User-supplied labels.
    #[prost(map = "string, string", tag = "3")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Effective resource limits.
    #[prost(message, optional, tag = "4")]
    pub limits: ::core::option::Option<ResourceLimits>,
    /// Network information.
    #[prost(message, optional, tag = "5")]
    pub network: ::core::option::Option<SandboxNetwork>,
    /// Creation timestamp (Unix seconds).
    #[prost(int64, tag = "6")]
    pub created_at: i64,
    /// Timestamp when the sandbox first became ready (Unix seconds, 0 if not yet).
    #[prost(int64, tag = "7")]
    pub ready_at: i64,
    /// Timestamp when the last workload exited (Unix seconds, 0 if none has run).
    #[prost(int64, tag = "8")]
    pub last_exited_at: i64,
    /// Exit code of the last workload (only meaningful when last_exited_at > 0).
    #[prost(int32, tag = "9")]
    pub last_exit_code: i32,
    /// Human-readable error message (only set when state == "failed").
    #[prost(string, tag = "10")]
    pub error: ::prost::alloc::string::String,
}
/// Network details of a sandbox.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxNetwork {
    /// Assigned IP address.
    #[prost(string, tag = "1")]
    pub ip_address: ::prost::alloc::string::String,
    /// Gateway address.
    #[prost(string, tag = "2")]
    pub gateway: ::prost::alloc::string::String,
    /// TAP interface name on the host.
    #[prost(string, tag = "3")]
    pub tap_name: ::prost::alloc::string::String,
}
/// Request to list sandboxes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesRequest {
    /// Filter by state (empty = all states).
    #[prost(string, tag = "1")]
    pub state: ::prost::alloc::string::String,
    /// Filter by labels (all key-value pairs must match).
    #[prost(map = "string, string", tag = "2")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Response to ListSandboxes.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSandboxesResponse {
    #[prost(message, repeated, tag = "1")]
    pub sandboxes: ::prost::alloc::vec::Vec<SandboxSummary>,
}
/// Lightweight sandbox summary for List.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxSummary {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// State.
    #[prost(string, tag = "2")]
    pub state: ::prost::alloc::string::String,
    /// Labels.
    #[prost(map = "string, string", tag = "3")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// IP address.
    #[prost(string, tag = "4")]
    pub ip_address: ::prost::alloc::string::String,
    /// Creation timestamp (Unix seconds).
    #[prost(int64, tag = "5")]
    pub created_at: i64,
}
/// Request to subscribe to sandbox lifecycle events.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxEventsRequest {
    /// Filter by sandbox ID (empty = all sandboxes).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Filter by event action (empty = all actions).
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
}
/// A sandbox lifecycle event.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SandboxEvent {
    /// Sandbox ID.
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Action:
    ///    "created"  — sandbox record created, VM booting
    ///    "ready"    — VM booted, sandbox accepting workloads
    ///    "running"  — a workload (cmd or Run) started
    ///    "idle"     — active workload exited, sandbox back to ready
    ///    "stopping" — Stop called, draining workload
    ///    "stopped"  — VM shut down
    ///    "failed"   — unrecoverable error
    ///    "removed"  — sandbox deleted
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    /// Unix nanoseconds.
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
    /// Additional context, e.g.:
    ///    "exit_code" on "idle" / "stopped"
    ///    "error"     on "failed"
    #[prost(map = "string, string", tag = "4")]
    pub attributes:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Request to checkpoint a sandbox.
/// The sandbox must be in "ready" or "idle" state (no active workload).
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointRequest {
    /// Sandbox ID to checkpoint.
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Human-readable label for the snapshot.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Labels attached to the snapshot.
    #[prost(map = "string, string", tag = "3")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Response to Checkpoint.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointResponse {
    /// Snapshot ID.
    #[prost(string, tag = "1")]
    pub snapshot_id: ::prost::alloc::string::String,
    /// On-disk directory containing vmstate and mem files.
    #[prost(string, tag = "2")]
    pub snapshot_dir: ::prost::alloc::string::String,
    /// Creation timestamp (RFC3339).
    #[prost(string, tag = "3")]
    pub created_at: ::prost::alloc::string::String,
}
/// Request to restore a sandbox from a snapshot.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreRequest {
    /// Caller-supplied ID for the new sandbox (empty = auto-generated).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Source snapshot ID.
    #[prost(string, tag = "2")]
    pub snapshot_id: ::prost::alloc::string::String,
    /// Labels to assign to the restored sandbox.
    #[prost(map = "string, string", tag = "3")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Assign a fresh TAP interface and IP. Required when running multiple
    /// sandboxes restored from the same snapshot concurrently.
    #[prost(bool, tag = "4")]
    pub network_override: bool,
    /// TTL for the restored sandbox in seconds (0 = no limit).
    #[prost(uint32, tag = "5")]
    pub ttl_seconds: u32,
}
/// Response to Restore.
/// The restored sandbox starts in "ready" state immediately.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreResponse {
    /// ID of the newly created sandbox.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Allocated IP address.
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
}
/// Request to list snapshots.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsRequest {
    /// Filter by the origin sandbox ID (empty = all).
    #[prost(string, tag = "1")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Filter by labels.
    #[prost(map = "string, string", tag = "2")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Response to ListSnapshots.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsResponse {
    #[prost(message, repeated, tag = "1")]
    pub snapshots: ::prost::alloc::vec::Vec<SnapshotSummary>,
}
/// Lightweight snapshot summary.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotSummary {
    /// Snapshot ID.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// ID of the sandbox that was checkpointed.
    #[prost(string, tag = "2")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// Human-readable label.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Labels.
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// On-disk directory.
    #[prost(string, tag = "5")]
    pub snapshot_dir: ::prost::alloc::string::String,
    /// Creation timestamp (RFC3339).
    #[prost(string, tag = "6")]
    pub created_at: ::prost::alloc::string::String,
}
/// Request to delete a snapshot.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSnapshotRequest {
    /// Snapshot ID.
    #[prost(string, tag = "1")]
    pub snapshot_id: ::prost::alloc::string::String,
}
