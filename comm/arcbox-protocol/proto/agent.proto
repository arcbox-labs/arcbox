// Agent service protocol definitions.
//
// This service runs inside the guest VM and handles requests from the host.
//
// Design sources:
// - internal-docs/architecture/cli-api.md (proto/agent.proto section)
// - kata-containers agent protocol (conceptual reference)
// - containerd shim v2 interface patterns

syntax = "proto3";

package arcbox.v1;

import "common.proto";

// AgentService runs inside the guest VM.
service AgentService {
    // Health check.
    rpc Ping(AgentPingRequest) returns (AgentPingResponse);

    // Gets system information.
    rpc GetSystemInfo(Empty) returns (SystemInfo);

    // Ensures guest runtime stack (containerd/dockerd) is ready.
    rpc EnsureRuntime(RuntimeEnsureRequest) returns (RuntimeEnsureResponse);

    // Gets guest runtime stack status.
    rpc GetRuntimeStatus(RuntimeStatusRequest) returns (RuntimeStatusResponse);

    // Creates a container.
    rpc CreateContainer(AgentCreateContainerRequest) returns (AgentCreateContainerResponse);

    // Starts a container.
    rpc StartContainer(AgentStartContainerRequest) returns (Empty);

    // Stops a container.
    rpc StopContainer(AgentStopContainerRequest) returns (Empty);

    // Removes a container.
    rpc RemoveContainer(AgentRemoveContainerRequest) returns (Empty);

    // Lists containers.
    rpc ListContainers(AgentListContainersRequest) returns (AgentListContainersResponse);

    // Reads a file from the guest filesystem.
    rpc ReadFile(ReadFileRequest) returns (stream FileChunk);

    // Writes a file to the guest filesystem.
    rpc WriteFile(stream FileChunk) returns (WriteFileResponse);

    // Executes a command.
    rpc Exec(AgentExecRequest) returns (stream AgentExecOutput);

    // Starts an exec session with full attach support.
    rpc ExecStart(AgentExecStartRequest) returns (stream AgentExecOutput);

    // Resizes exec TTY.
    rpc ExecResize(AgentExecResizeRequest) returns (Empty);

    // Attaches to a running container for interactive I/O.
    rpc Attach(AgentAttachRequest) returns (stream AgentAttachOutput);

    // Gets container stats.
    rpc Stats(AgentStatsRequest) returns (stream AgentContainerStats);

    // Gets container logs.
    rpc Logs(AgentLogsRequest) returns (stream AgentLogEntry);
}

// Ping request.
message AgentPingRequest {
    // Optional payload.
    string message = 1;
}

// Ping response.
message AgentPingResponse {
    // Response payload.
    string message = 1;
    // Agent version.
    string version = 2;
}

// System information from the guest.
message SystemInfo {
    // Kernel version.
    string kernel_version = 1;
    // OS name.
    string os_name = 2;
    // OS version.
    string os_version = 3;
    // Architecture.
    string arch = 4;
    // Total memory in bytes.
    uint64 total_memory = 5;
    // Available memory in bytes.
    uint64 available_memory = 6;
    // Number of CPUs.
    uint32 cpu_count = 7;
    // Load average (1, 5, 15 minutes).
    repeated double load_average = 8;
    // Hostname.
    string hostname = 9;
    // Uptime in seconds.
    uint64 uptime = 10;
    // Guest IP addresses (excluding loopback).
    repeated string ip_addresses = 11;
}

// Request to ensure runtime services are available.
message RuntimeEnsureRequest {
    // Whether to attempt starting services when not ready.
    bool start_if_needed = 1;
}

// Response from runtime ensure operation.
message RuntimeEnsureResponse {
    // Whether runtime is ready for Docker API requests.
    bool ready = 1;
    // Runtime endpoint exposed to host proxy.
    string endpoint = 2;
    // Additional status detail.
    string message = 3;
    // Outcome of this ensure call: "started", "reused", or "failed".
    string status = 4;
}

// Request for runtime status.
message RuntimeStatusRequest {}

// Runtime status report.
message RuntimeStatusResponse {
    // Whether containerd socket is reachable.
    bool containerd_ready = 1;
    // Whether Docker socket is reachable.
    bool docker_ready = 2;
    // Runtime endpoint exposed to host proxy.
    string endpoint = 3;
    // Human-readable detail for diagnostics.
    string detail = 4;
    // Per-service status entries for fine-grained observability.
    repeated ServiceStatus services = 5;
}

// Notification that a container's published port bindings changed.
message PortBindingsChanged {
    // Container ID.
    string container_id = 1;
    // Current published bindings from dockerd inspect output.
    repeated PortBinding bindings = 2;
}

// Notification that a container no longer has active published ports.
message PortBindingsRemoved {
    // Container ID.
    string container_id = 1;
}

// Individual service status within the guest runtime stack.
message ServiceStatus {
    // Service name (e.g. "containerd", "dockerd", "youki").
    string name = 1;
    // Service status: "ready", "not_ready", or "error".
    string status = 2;
    // Human-readable detail for diagnostics (error message, socket path, etc.).
    string detail = 3;
}

// Request to create a container (forwarded to containerd).
message AgentCreateContainerRequest {
    // Container name.
    string name = 1;
    // Image reference.
    string image = 2;
    // Command to run.
    repeated string cmd = 3;
    // Entrypoint.
    repeated string entrypoint = 4;
    // Environment variables.
    map<string, string> env = 5;
    // Working directory.
    string working_dir = 6;
    // User.
    string user = 7;
    // Mounts.
    repeated Mount mounts = 8;
    // TTY allocation.
    bool tty = 9;
    // Keep stdin open.
    bool open_stdin = 10;
    // Root filesystem path (extracted OCI image).
    // When set, the container will be chrooted into this directory.
    string rootfs = 11;
    // Optional container ID to keep host/guest IDs in sync.
    string id = 12;
}

// Response to create container.
message AgentCreateContainerResponse {
    // Container ID.
    string id = 1;
}

// Request to start a container.
message AgentStartContainerRequest {
    // Container ID.
    string id = 1;
}

// Request to stop a container.
message AgentStopContainerRequest {
    // Container ID.
    string id = 1;
    // Timeout in seconds.
    uint32 timeout = 2;
}

// Request to remove a container.
message AgentRemoveContainerRequest {
    // Container ID.
    string id = 1;
    // Force removal.
    bool force = 2;
}

// Request to list containers.
message AgentListContainersRequest {
    // Show all containers.
    bool all = 1;
}

// Response to list containers.
message AgentListContainersResponse {
    // List of containers.
    repeated AgentContainerInfo containers = 1;
}

// Container information.
message AgentContainerInfo {
    // Container ID.
    string id = 1;
    // Container name.
    string name = 2;
    // Image reference.
    string image = 3;
    // State.
    string state = 4;
    // Status.
    string status = 5;
    // Creation time.
    int64 created = 6;
}

// Request to read a file.
message ReadFileRequest {
    // File path.
    string path = 1;
    // Offset in bytes.
    int64 offset = 2;
    // Maximum bytes to read (0 = all).
    int64 limit = 3;
}

// File chunk for streaming file operations.
message FileChunk {
    // File path (only in first chunk for writes).
    string path = 1;
    // File data.
    bytes data = 2;
    // Offset in file.
    int64 offset = 3;
    // Is this the last chunk.
    bool eof = 4;
    // File mode (only for writes, in first chunk).
    uint32 mode = 5;
}

// Response to write file.
message WriteFileResponse {
    // Bytes written.
    int64 bytes_written = 1;
}

// Request to execute a command.
message AgentExecRequest {
    // Container ID (empty for host).
    string container_id = 1;
    // Command to execute.
    repeated string cmd = 2;
    // Environment variables.
    map<string, string> env = 3;
    // Working directory.
    string working_dir = 4;
    // User to run as.
    string user = 5;
    // Allocate TTY.
    bool tty = 6;
}

// Exec output.
message AgentExecOutput {
    // Stream type: stdout, stderr.
    string stream = 1;
    // Output data.
    bytes data = 2;
    // Exit code (only set when done).
    int32 exit_code = 3;
    // Is this the final message.
    bool done = 4;
}

// Request to start an exec instance with full options.
message AgentExecStartRequest {
    // Exec ID.
    string exec_id = 1;
    // Container ID.
    string container_id = 2;
    // Command to execute.
    repeated string cmd = 3;
    // Environment variables.
    map<string, string> env = 4;
    // Working directory.
    string working_dir = 5;
    // User to run as.
    string user = 6;
    // Allocate TTY.
    bool tty = 7;
    // Detach mode (run in background).
    bool detach = 8;
    // Initial terminal width.
    uint32 tty_width = 9;
    // Initial terminal height.
    uint32 tty_height = 10;
}

// Exec start response.
message AgentExecStartResponse {
    // Process ID in guest.
    uint32 pid = 1;
}

// Request to resize exec TTY.
message AgentExecResizeRequest {
    // Exec ID.
    string exec_id = 1;
    // New terminal width.
    uint32 width = 2;
    // New terminal height.
    uint32 height = 3;
}

// Attach request for container interactive session.
message AgentAttachRequest {
    // Container ID to attach to.
    string container_id = 1;
    // Attach stdin.
    bool attach_stdin = 2;
    // Attach stdout.
    bool attach_stdout = 3;
    // Attach stderr.
    bool attach_stderr = 4;
    // Terminal width for TTY containers.
    uint32 tty_width = 5;
    // Terminal height for TTY containers.
    uint32 tty_height = 6;
    // Exec session ID when attaching to an exec.
    string exec_id = 7;
}

// Attach input for stdin/resizes.
message AgentAttachInput {
    // Raw input data for the container.
    bytes data = 1;
    // Resize flag.
    bool resize = 2;
    // New terminal width (when resize=true).
    uint32 width = 3;
    // New terminal height (when resize=true).
    uint32 height = 4;
}

// Attach output for stdout/stderr.
message AgentAttachOutput {
    // Stream name: stdout/stderr.
    string stream = 1;
    // Output data chunk.
    bytes data = 2;
}

// Request for container stats.
message AgentStatsRequest {
    // Container ID.
    string container_id = 1;
    // Stream updates.
    bool stream = 2;
}

// Container statistics.
message AgentContainerStats {
    // Container ID.
    string container_id = 1;
    // CPU usage.
    AgentCpuStats cpu = 2;
    // Memory usage.
    AgentMemoryStats memory = 3;
    // Network I/O.
    AgentNetworkStats network = 4;
    // Block I/O.
    AgentBlockStats block = 5;
    // Timestamp.
    Timestamp timestamp = 6;
}

// CPU statistics.
message AgentCpuStats {
    // CPU usage in nanoseconds.
    uint64 usage_ns = 1;
    // System CPU usage in nanoseconds.
    uint64 system_ns = 2;
    // CPU usage percentage.
    double usage_percent = 3;
}

// Memory statistics.
message AgentMemoryStats {
    // Memory usage in bytes.
    uint64 usage = 1;
    // Memory limit in bytes.
    uint64 limit = 2;
    // Memory usage percentage.
    double usage_percent = 3;
    // Cache in bytes.
    uint64 cache = 4;
}

// Network statistics.
message AgentNetworkStats {
    // Bytes received.
    uint64 rx_bytes = 1;
    // Bytes transmitted.
    uint64 tx_bytes = 2;
    // Packets received.
    uint64 rx_packets = 3;
    // Packets transmitted.
    uint64 tx_packets = 4;
}

// Block I/O statistics.
message AgentBlockStats {
    // Bytes read.
    uint64 read_bytes = 1;
    // Bytes written.
    uint64 write_bytes = 2;
}

// Request for container logs.
message AgentLogsRequest {
    // Container ID.
    string container_id = 1;
    // Follow logs (stream new entries).
    bool follow = 2;
    // Include stdout.
    bool stdout = 3;
    // Include stderr.
    bool stderr = 4;
    // Only entries since this timestamp (Unix seconds, 0 = all).
    int64 since = 5;
    // Only entries until this timestamp (Unix seconds, 0 = now).
    int64 until = 6;
    // Include timestamps in output.
    bool timestamps = 7;
    // Tail N lines (0 = all).
    int64 tail = 8;
}

// Log entry.
message AgentLogEntry {
    // Stream type: "stdout" or "stderr".
    string stream = 1;
    // Log data.
    bytes data = 2;
    // Timestamp (Unix nanoseconds).
    int64 timestamp = 3;
}
